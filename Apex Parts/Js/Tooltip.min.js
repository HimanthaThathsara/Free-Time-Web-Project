
!function () { "use strict"; try { if (typeof document < "u") { var t = document.createElement("style"); t.appendChild(document.createTextNode('.tippy-box[data-animation=fade][data-state=hidden]{opacity:0}[data-tippy-root]{max-width:calc(100vw - 10px)}.tippy-box{position:relative;background-color:#333;color:#fff;border-radius:4px;font-size:14px;line-height:1.4;white-space:normal;outline:0;transition-property:transform,visibility,opacity}.tippy-box[data-placement^=top]>.tippy-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-arrow:before{bottom:-7px;left:0;border-width:8px 8px 0;border-top-color:initial;transform-origin:center top}.tippy-box[data-placement^=bottom]>.tippy-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-arrow:before{top:-7px;left:0;border-width:0 8px 8px;border-bottom-color:initial;transform-origin:center bottom}.tippy-box[data-placement^=left]>.tippy-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-arrow:before{border-width:8px 0 8px 8px;border-left-color:initial;right:-7px;transform-origin:center left}.tippy-box[data-placement^=right]>.tippy-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-arrow:before{left:-7px;border-width:8px 8px 8px 0;border-right-color:initial;transform-origin:center right}.tippy-box[data-inertia][data-state=visible]{transition-timing-function:cubic-bezier(.54,1.5,.38,1.11)}.tippy-arrow{width:16px;height:16px;color:#333}.tippy-arrow:before{content:"";position:absolute;border-color:transparent;border-style:solid}.tippy-content{position:relative;padding:5px 9px;z-index:1}.tippy-box[data-theme~=translucent]{background-color:#000000b3}.tippy-box[data-theme~=translucent]>.tippy-arrow{width:14px;height:14px}.tippy-box[data-theme~=translucent][data-placement^=top]>.tippy-arrow:before{border-width:7px 7px 0;border-top-color:#000000b3}.tippy-box[data-theme~=translucent][data-placement^=bottom]>.tippy-arrow:before{border-width:0 7px 7px;border-bottom-color:#000000b3}.tippy-box[data-theme~=translucent][data-placement^=left]>.tippy-arrow:before{border-width:7px 0 7px 7px;border-left-color:#000000b3}.tippy-box[data-theme~=translucent][data-placement^=right]>.tippy-arrow:before{border-width:7px 7px 7px 0;border-right-color:#000000b3}.tippy-box[data-theme~=translucent]>.tippy-backdrop{background-color:#000000b3}.tippy-box[data-theme~=translucent]>.tippy-svg-arrow{fill:#000000b3}.tippy-box[data-theme~=material]{background-color:#505355;font-weight:600}.tippy-box[data-theme~=material][data-placement^=top]>.tippy-arrow:before{border-top-color:#505355}.tippy-box[data-theme~=material][data-placement^=bottom]>.tippy-arrow:before{border-bottom-color:#505355}.tippy-box[data-theme~=material][data-placement^=left]>.tippy-arrow:before{border-left-color:#505355}.tippy-box[data-theme~=material][data-placement^=right]>.tippy-arrow:before{border-right-color:#505355}.tippy-box[data-theme~=material]>.tippy-backdrop{background-color:#505355}.tippy-box[data-theme~=material]>.tippy-svg-arrow{fill:#505355}.tippy-box[data-theme~=light]{color:#26323d;box-shadow:0 0 20px 4px #9aa1b126,0 4px 80px -8px #24282f40,0 4px 4px -2px #5b5e6926;background-color:#fff}.tippy-box[data-theme~=light][data-placement^=top]>.tippy-arrow:before{border-top-color:#fff}.tippy-box[data-theme~=light][data-placement^=bottom]>.tippy-arrow:before{border-bottom-color:#fff}.tippy-box[data-theme~=light][data-placement^=left]>.tippy-arrow:before{border-left-color:#fff}.tippy-box[data-theme~=light][data-placement^=right]>.tippy-arrow:before{border-right-color:#fff}.tippy-box[data-theme~=light]>.tippy-backdrop{background-color:#fff}.tippy-box[data-theme~=light]>.tippy-svg-arrow{fill:#fff}.tippy-box[data-animation=shift-toward][data-state=hidden]{opacity:0}.tippy-box[data-animation=shift-toward][data-state=hidden][data-placement^=top]{transform:translateY(-10px)}.tippy-box[data-animation=shift-toward][data-state=hidden][data-placement^=bottom]{transform:translateY(10px)}.tippy-box[data-animation=shift-toward][data-state=hidden][data-placement^=left]{transform:translate(-10px)}.tippy-box[data-animation=shift-toward][data-state=hidden][data-placement^=right]{transform:translate(10px)}.tippy-box[data-animation=perspective][data-placement^=top]{transform-origin:bottom}.tippy-box[data-animation=perspective][data-placement^=top][data-state=visible]{transform:perspective(700px)}.tippy-box[data-animation=perspective][data-placement^=top][data-state=hidden]{transform:perspective(700px) translateY(8px) rotateX(60deg)}.tippy-box[data-animation=perspective][data-placement^=bottom]{transform-origin:top}.tippy-box[data-animation=perspective][data-placement^=bottom][data-state=visible]{transform:perspective(700px)}.tippy-box[data-animation=perspective][data-placement^=bottom][data-state=hidden]{transform:perspective(700px) translateY(-8px) rotateX(-60deg)}.tippy-box[data-animation=perspective][data-placement^=left]{transform-origin:right}.tippy-box[data-animation=perspective][data-placement^=left][data-state=visible]{transform:perspective(700px)}.tippy-box[data-animation=perspective][data-placement^=left][data-state=hidden]{transform:perspective(700px) translate(8px) rotateY(-60deg)}.tippy-box[data-animation=perspective][data-placement^=right]{transform-origin:left}.tippy-box[data-animation=perspective][data-placement^=right][data-state=visible]{transform:perspective(700px)}.tippy-box[data-animation=perspective][data-placement^=right][data-state=hidden]{transform:perspective(700px) translate(-8px) rotateY(60deg)}.tippy-box[data-animation=perspective][data-state=hidden],.tippy-box[data-animation=shift-away][data-state=hidden]{opacity:0}.tippy-box[data-animation=shift-away][data-state=hidden][data-placement^=top]{transform:translateY(10px)}.tippy-box[data-animation=shift-away][data-state=hidden][data-placement^=bottom]{transform:translateY(-10px)}.tippy-box[data-animation=shift-away][data-state=hidden][data-placement^=left]{transform:translate(10px)}.tippy-box[data-animation=shift-away][data-state=hidden][data-placement^=right]{transform:translate(-10px)}.tippy-box[data-animation=scale][data-placement^=top]{transform-origin:bottom}.tippy-box[data-animation=scale][data-placement^=bottom]{transform-origin:top}.tippy-box[data-animation=scale][data-placement^=left]{transform-origin:right}.tippy-box[data-animation=scale][data-placement^=right]{transform-origin:left}.tippy-box[data-animation=scale][data-state=hidden]{transform:scale(.5);opacity:0}.tippy-box[data-placement^=top]>.tippy-svg-arrow{bottom:0}.tippy-box[data-placement^=top]>.tippy-svg-arrow:after,.tippy-box[data-placement^=top]>.tippy-svg-arrow>svg{top:16px;transform:rotate(180deg)}.tippy-box[data-placement^=bottom]>.tippy-svg-arrow{top:0}.tippy-box[data-placement^=bottom]>.tippy-svg-arrow>svg{bottom:16px}.tippy-box[data-placement^=left]>.tippy-svg-arrow{right:0}.tippy-box[data-placement^=left]>.tippy-svg-arrow:after,.tippy-box[data-placement^=left]>.tippy-svg-arrow>svg{transform:rotate(90deg);top:calc(50% - 3px);left:11px}.tippy-box[data-placement^=right]>.tippy-svg-arrow{left:0}.tippy-box[data-placement^=right]>.tippy-svg-arrow:after,.tippy-box[data-placement^=right]>.tippy-svg-arrow>svg{transform:rotate(-90deg);top:calc(50% - 3px);right:11px}.tippy-svg-arrow{width:16px;height:16px;fill:#333;text-align:initial}.tippy-svg-arrow,.tippy-svg-arrow>svg{position:absolute}')), document.head.appendChild(t) } } catch (t) { console.error("vite-plugin-css-injected-by-js", t) } }(), function () { "use strict"; var t = "top", e = "bottom", n = "right", o = "left", i = "auto", r = [t, e, n, o], a = "start", s = "end", p = "viewport", c = "popper", d = r.reduce((function (t, e) { return t.concat([e + "-" + a, e + "-" + s]) }), []), l = [].concat(r, [i]).reduce((function (t, e) { return t.concat([e, e + "-" + a, e + "-" + s]) }), []), f = ["beforeRead", "read", "afterRead", "beforeMain", "main", "afterMain", "beforeWrite", "write", "afterWrite"]; function u(t) { return t ? (t.nodeName || "").toLowerCase() : null } function m(t) { if (null == t) return window; if ("[object Window]" !== t.toString()) { var e = t.ownerDocument; return e && e.defaultView || window } return t } function h(t) { return t instanceof m(t).Element || t instanceof Element } function b(t) { return t instanceof m(t).HTMLElement || t instanceof HTMLElement } function v(t) { return !(typeof ShadowRoot > "u") && (t instanceof m(t).ShadowRoot || t instanceof ShadowRoot) } const y = { name: "applyStyles", enabled: !0, phase: "write", fn: function (t) { var e = t.state; Object.keys(e.elements).forEach((function (t) { var n = e.styles[t] || {}, o = e.attributes[t] || {}, i = e.elements[t]; !b(i) || !u(i) || (Object.assign(i.style, n), Object.keys(o).forEach((function (t) { var e = o[t]; !1 === e ? i.removeAttribute(t) : i.setAttribute(t, !0 === e ? "" : e) }))) })) }, effect: function (t) { var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; return Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow), function () { Object.keys(e.elements).forEach((function (t) { var o = e.elements[t], i = e.attributes[t] || {}, r = Object.keys(e.styles.hasOwnProperty(t) ? e.styles[t] : n[t]).reduce((function (t, e) { return t[e] = "", t }), {}); !b(o) || !u(o) || (Object.assign(o.style, r), Object.keys(i).forEach((function (t) { o.removeAttribute(t) }))) })) } }, requires: ["computeStyles"] }; function g(t) { return t.split("-")[0] } var x = Math.max, w = Math.min, O = Math.round; function E() { var t = navigator.userAgentData; return null != t && t.brands && Array.isArray(t.brands) ? t.brands.map((function (t) { return t.brand + "/" + t.version })).join(" ") : navigator.userAgent } function A() { return !/^((?!chrome|android).)*safari/i.test(E()) } function j(t, e, n) { void 0 === e && (e = !1), void 0 === n && (n = !1); var o = t.getBoundingClientRect(), i = 1, r = 1; e && b(t) && (i = t.offsetWidth > 0 && O(o.width) / t.offsetWidth || 1, r = t.offsetHeight > 0 && O(o.height) / t.offsetHeight || 1); var a = (h(t) ? m(t) : window).visualViewport, s = !A() && n, p = (o.left + (s && a ? a.offsetLeft : 0)) / i, c = (o.top + (s && a ? a.offsetTop : 0)) / r, d = o.width / i, l = o.height / r; return { width: d, height: l, top: c, right: p + d, bottom: c + l, left: p, x: p, y: c } } function T(t) { var e = j(t), n = t.offsetWidth, o = t.offsetHeight; return Math.abs(e.width - n) <= 1 && (n = e.width), Math.abs(e.height - o) <= 1 && (o = e.height), { x: t.offsetLeft, y: t.offsetTop, width: n, height: o } } function D(t, e) { var n = e.getRootNode && e.getRootNode(); if (t.contains(e)) return !0; if (n && v(n)) { var o = e; do { if (o && t.isSameNode(o)) return !0; o = o.parentNode || o.host } while (o) } return !1 } function k(t) { return m(t).getComputedStyle(t) } function L(t) { return ["table", "td", "th"].indexOf(u(t)) >= 0 } function N(t) { return ((h(t) ? t.ownerDocument : t.document) || window.document).documentElement } function V(t) { return "html" === u(t) ? t : t.assignedSlot || t.parentNode || (v(t) ? t.host : null) || N(t) } function C(t) { return b(t) && "fixed" !== k(t).position ? t.offsetParent : null } function S(t) { for (var e = m(t), n = C(t); n && L(n) && "static" === k(n).position;)n = C(n); return n && ("html" === u(n) || "body" === u(n) && "static" === k(n).position) ? e : n || function (t) { var e = /firefox/i.test(E()); if (/Trident/i.test(E()) && b(t) && "fixed" === k(t).position) return null; var n = V(t); for (v(n) && (n = n.host); b(n) && ["html", "body"].indexOf(u(n)) < 0;) { var o = k(n); if ("none" !== o.transform || "none" !== o.perspective || "paint" === o.contain || -1 !== ["transform", "perspective"].indexOf(o.willChange) || e && "filter" === o.willChange || e && o.filter && "none" !== o.filter) return n; n = n.parentNode } return null }(t) || e } function M(t) { return ["top", "bottom"].indexOf(t) >= 0 ? "x" : "y" } function H(t, e, n) { return x(t, w(e, n)) } function P(t) { return Object.assign({}, { top: 0, right: 0, bottom: 0, left: 0 }, t) } function B(t, e) { return e.reduce((function (e, n) { return e[n] = t, e }), {}) } const R = { name: "arrow", enabled: !0, phase: "main", fn: function (i) { var a, s = i.state, p = i.name, c = i.options, d = s.elements.arrow, l = s.modifiersData.popperOffsets, f = g(s.placement), u = M(f), m = [o, n].indexOf(f) >= 0 ? "height" : "width"; if (d && l) { var h = function (t, e) { return P("number" != typeof (t = "function" == typeof t ? t(Object.assign({}, e.rects, { placement: e.placement })) : t) ? t : B(t, r)) }(c.padding, s), b = T(d), v = "y" === u ? t : o, y = "y" === u ? e : n, x = s.rects.reference[m] + s.rects.reference[u] - l[u] - s.rects.popper[m], w = l[u] - s.rects.reference[u], O = S(d), E = O ? "y" === u ? O.clientHeight || 0 : O.clientWidth || 0 : 0, A = x / 2 - w / 2, j = h[v], D = E - b[m] - h[y], k = E / 2 - b[m] / 2 + A, L = H(j, k, D), N = u; s.modifiersData[p] = ((a = {})[N] = L, a.centerOffset = L - k, a) } }, effect: function (t) { var e = t.state, n = t.options.element, o = void 0 === n ? "[data-popper-arrow]" : n; null != o && ("string" == typeof o && !(o = e.elements.popper.querySelector(o)) || D(e.elements.popper, o) && (e.elements.arrow = o)) }, requires: ["popperOffsets"], requiresIfExists: ["preventOverflow"] }; function W(t) { return t.split("-")[1] } var I = { top: "auto", right: "auto", bottom: "auto", left: "auto" }; function _(i) { var r, a = i.popper, p = i.popperRect, c = i.placement, d = i.variation, l = i.offsets, f = i.position, u = i.gpuAcceleration, h = i.adaptive, b = i.roundOffsets, v = i.isFixed, y = l.x, g = void 0 === y ? 0 : y, x = l.y, w = void 0 === x ? 0 : x, E = "function" == typeof b ? b({ x: g, y: w }) : { x: g, y: w }; g = E.x, w = E.y; var A = l.hasOwnProperty("x"), j = l.hasOwnProperty("y"), T = o, D = t, L = window; if (h) { var V = S(a), C = "clientHeight", M = "clientWidth"; if (V === m(a) && ("static" !== k(V = N(a)).position && "absolute" === f && (C = "scrollHeight", M = "scrollWidth")), c === t || (c === o || c === n) && d === s) D = e, w -= (v && V === L && L.visualViewport ? L.visualViewport.height : V[C]) - p.height, w *= u ? 1 : -1; if (c === o || (c === t || c === e) && d === s) T = n, g -= (v && V === L && L.visualViewport ? L.visualViewport.width : V[M]) - p.width, g *= u ? 1 : -1 } var H, P = Object.assign({ position: f }, h && I), B = !0 === b ? function (t, e) { var n = t.x, o = t.y, i = e.devicePixelRatio || 1; return { x: O(n * i) / i || 0, y: O(o * i) / i || 0 } }({ x: g, y: w }, m(a)) : { x: g, y: w }; return g = B.x, w = B.y, u ? Object.assign({}, P, ((H = {})[D] = j ? "0" : "", H[T] = A ? "0" : "", H.transform = (L.devicePixelRatio || 1) <= 1 ? "translate(" + g + "px, " + w + "px)" : "translate3d(" + g + "px, " + w + "px, 0)", H)) : Object.assign({}, P, ((r = {})[D] = j ? w + "px" : "", r[T] = A ? g + "px" : "", r.transform = "", r)) } const U = { name: "computeStyles", enabled: !0, phase: "beforeWrite", fn: function (t) { var e = t.state, n = t.options, o = n.gpuAcceleration, i = void 0 === o || o, r = n.adaptive, a = void 0 === r || r, s = n.roundOffsets, p = void 0 === s || s, c = { placement: g(e.placement), variation: W(e.placement), popper: e.elements.popper, popperRect: e.rects.popper, gpuAcceleration: i, isFixed: "fixed" === e.options.strategy }; null != e.modifiersData.popperOffsets && (e.styles.popper = Object.assign({}, e.styles.popper, _(Object.assign({}, c, { offsets: e.modifiersData.popperOffsets, position: e.options.strategy, adaptive: a, roundOffsets: p })))), null != e.modifiersData.arrow && (e.styles.arrow = Object.assign({}, e.styles.arrow, _(Object.assign({}, c, { offsets: e.modifiersData.arrow, position: "absolute", adaptive: !1, roundOffsets: p })))), e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-placement": e.placement }) }, data: {} }; var q = { passive: !0 }; const $ = { name: "eventListeners", enabled: !0, phase: "write", fn: function () { }, effect: function (t) { var e = t.state, n = t.instance, o = t.options, i = o.scroll, r = void 0 === i || i, a = o.resize, s = void 0 === a || a, p = m(e.elements.popper), c = [].concat(e.scrollParents.reference, e.scrollParents.popper); return r && c.forEach((function (t) { t.addEventListener("scroll", n.update, q) })), s && p.addEventListener("resize", n.update, q), function () { r && c.forEach((function (t) { t.removeEventListener("scroll", n.update, q) })), s && p.removeEventListener("resize", n.update, q) } }, data: {} }; var Y = { left: "right", right: "left", bottom: "top", top: "bottom" }; function z(t) { return t.replace(/left|right|bottom|top/g, (function (t) { return Y[t] })) } var F = { start: "end", end: "start" }; function X(t) { return t.replace(/start|end/g, (function (t) { return F[t] })) } function J(t) { var e = m(t); return { scrollLeft: e.pageXOffset, scrollTop: e.pageYOffset } } function G(t) { return j(N(t)).left + J(t).scrollLeft } function K(t) { var e = k(t), n = e.overflow, o = e.overflowX, i = e.overflowY; return /auto|scroll|overlay|hidden/.test(n + i + o) } function Q(t) { return ["html", "body", "#document"].indexOf(u(t)) >= 0 ? t.ownerDocument.body : b(t) && K(t) ? t : Q(V(t)) } function Z(t, e) { var n; void 0 === e && (e = []); var o = Q(t), i = o === (null == (n = t.ownerDocument) ? void 0 : n.body), r = m(o), a = i ? [r].concat(r.visualViewport || [], K(o) ? o : []) : o, s = e.concat(a); return i ? s : s.concat(Z(V(a))) } function tt(t) { return Object.assign({}, t, { left: t.x, top: t.y, right: t.x + t.width, bottom: t.y + t.height }) } function et(t, e, n) { return e === p ? tt(function (t, e) { var n = m(t), o = N(t), i = n.visualViewport, r = o.clientWidth, a = o.clientHeight, s = 0, p = 0; if (i) { r = i.width, a = i.height; var c = A(); (c || !c && "fixed" === e) && (s = i.offsetLeft, p = i.offsetTop) } return { width: r, height: a, x: s + G(t), y: p } }(t, n)) : h(e) ? function (t, e) { var n = j(t, !1, "fixed" === e); return n.top = n.top + t.clientTop, n.left = n.left + t.clientLeft, n.bottom = n.top + t.clientHeight, n.right = n.left + t.clientWidth, n.width = t.clientWidth, n.height = t.clientHeight, n.x = n.left, n.y = n.top, n }(e, n) : tt(function (t) { var e, n = N(t), o = J(t), i = null == (e = t.ownerDocument) ? void 0 : e.body, r = x(n.scrollWidth, n.clientWidth, i ? i.scrollWidth : 0, i ? i.clientWidth : 0), a = x(n.scrollHeight, n.clientHeight, i ? i.scrollHeight : 0, i ? i.clientHeight : 0), s = -o.scrollLeft + G(t), p = -o.scrollTop; return "rtl" === k(i || n).direction && (s += x(n.clientWidth, i ? i.clientWidth : 0) - r), { width: r, height: a, x: s, y: p } }(N(t))) } function nt(t, e, n, o) { var i = "clippingParents" === e ? function (t) { var e = Z(V(t)), n = ["absolute", "fixed"].indexOf(k(t).position) >= 0 && b(t) ? S(t) : t; return h(n) ? e.filter((function (t) { return h(t) && D(t, n) && "body" !== u(t) })) : [] }(t) : [].concat(e), r = [].concat(i, [n]), a = r[0], s = r.reduce((function (e, n) { var i = et(t, n, o); return e.top = x(i.top, e.top), e.right = w(i.right, e.right), e.bottom = w(i.bottom, e.bottom), e.left = x(i.left, e.left), e }), et(t, a, o)); return s.width = s.right - s.left, s.height = s.bottom - s.top, s.x = s.left, s.y = s.top, s } function ot(i) { var r, p = i.reference, c = i.element, d = i.placement, l = d ? g(d) : null, f = d ? W(d) : null, u = p.x + p.width / 2 - c.width / 2, m = p.y + p.height / 2 - c.height / 2; switch (l) { case t: r = { x: u, y: p.y - c.height }; break; case e: r = { x: u, y: p.y + p.height }; break; case n: r = { x: p.x + p.width, y: m }; break; case o: r = { x: p.x - c.width, y: m }; break; default: r = { x: p.x, y: p.y } }var h = l ? M(l) : null; if (null != h) { var b = "y" === h ? "height" : "width"; switch (f) { case a: r[h] = r[h] - (p[b] / 2 - c[b] / 2); break; case s: r[h] = r[h] + (p[b] / 2 - c[b] / 2) } } return r } function it(o, i) { void 0 === i && (i = {}); var a = i, s = a.placement, d = void 0 === s ? o.placement : s, l = a.strategy, f = void 0 === l ? o.strategy : l, u = a.boundary, m = void 0 === u ? "clippingParents" : u, b = a.rootBoundary, v = void 0 === b ? p : b, y = a.elementContext, g = void 0 === y ? c : y, x = a.altBoundary, w = void 0 !== x && x, O = a.padding, E = void 0 === O ? 0 : O, A = P("number" != typeof E ? E : B(E, r)), T = g === c ? "reference" : c, D = o.rects.popper, k = o.elements[w ? T : g], L = nt(h(k) ? k : k.contextElement || N(o.elements.popper), m, v, f), V = j(o.elements.reference), C = ot({ reference: V, element: D, strategy: "absolute", placement: d }), S = tt(Object.assign({}, D, C)), M = g === c ? S : V, H = { top: L.top - M.top + A.top, bottom: M.bottom - L.bottom + A.bottom, left: L.left - M.left + A.left, right: M.right - L.right + A.right }, R = o.modifiersData.offset; if (g === c && R) { var W = R[d]; Object.keys(H).forEach((function (o) { var i = [n, e].indexOf(o) >= 0 ? 1 : -1, r = [t, e].indexOf(o) >= 0 ? "y" : "x"; H[o] += W[r] * i })) } return H } const rt = { name: "flip", enabled: !0, phase: "main", fn: function (s) { var p = s.state, c = s.options, f = s.name; if (!p.modifiersData[f]._skip) { for (var u = c.mainAxis, m = void 0 === u || u, h = c.altAxis, b = void 0 === h || h, v = c.fallbackPlacements, y = c.padding, x = c.boundary, w = c.rootBoundary, O = c.altBoundary, E = c.flipVariations, A = void 0 === E || E, j = c.allowedAutoPlacements, T = p.options.placement, D = g(T), k = v || (D === T || !A ? [z(T)] : function (t) { if (g(t) === i) return []; var e = z(t); return [X(t), e, X(e)] }(T)), L = [T].concat(k).reduce((function (t, e) { return t.concat(g(e) === i ? function (t, e) { void 0 === e && (e = {}); var n = e, o = n.placement, i = n.boundary, a = n.rootBoundary, s = n.padding, p = n.flipVariations, c = n.allowedAutoPlacements, f = void 0 === c ? l : c, u = W(o), m = u ? p ? d : d.filter((function (t) { return W(t) === u })) : r, h = m.filter((function (t) { return f.indexOf(t) >= 0 })); 0 === h.length && (h = m); var b = h.reduce((function (e, n) { return e[n] = it(t, { placement: n, boundary: i, rootBoundary: a, padding: s })[g(n)], e }), {}); return Object.keys(b).sort((function (t, e) { return b[t] - b[e] })) }(p, { placement: e, boundary: x, rootBoundary: w, padding: y, flipVariations: A, allowedAutoPlacements: j }) : e) }), []), N = p.rects.reference, V = p.rects.popper, C = new Map, S = !0, M = L[0], H = 0; H < L.length; H++) { var P = L[H], B = g(P), R = W(P) === a, I = [t, e].indexOf(B) >= 0, _ = I ? "width" : "height", U = it(p, { placement: P, boundary: x, rootBoundary: w, altBoundary: O, padding: y }), q = I ? R ? n : o : R ? e : t; N[_] > V[_] && (q = z(q)); var $ = z(q), Y = []; if (m && Y.push(U[B] <= 0), b && Y.push(U[q] <= 0, U[$] <= 0), Y.every((function (t) { return t }))) { M = P, S = !1; break } C.set(P, Y) } if (S) for (var F = function (t) { var e = L.find((function (e) { var n = C.get(e); if (n) return n.slice(0, t).every((function (t) { return t })) })); if (e) return M = e, "break" }, J = A ? 3 : 1; J > 0; J--) { if ("break" === F(J)) break } p.placement !== M && (p.modifiersData[f]._skip = !0, p.placement = M, p.reset = !0) } }, requiresIfExists: ["offset"], data: { _skip: !1 } }; function at(t, e, n) { return void 0 === n && (n = { x: 0, y: 0 }), { top: t.top - e.height - n.y, right: t.right - e.width + n.x, bottom: t.bottom - e.height + n.y, left: t.left - e.width - n.x } } function st(i) { return [t, n, e, o].some((function (t) { return i[t] >= 0 })) } const pt = { name: "hide", enabled: !0, phase: "main", requiresIfExists: ["preventOverflow"], fn: function (t) { var e = t.state, n = t.name, o = e.rects.reference, i = e.rects.popper, r = e.modifiersData.preventOverflow, a = it(e, { elementContext: "reference" }), s = it(e, { altBoundary: !0 }), p = at(a, o), c = at(s, i, r), d = st(p), l = st(c); e.modifiersData[n] = { referenceClippingOffsets: p, popperEscapeOffsets: c, isReferenceHidden: d, hasPopperEscaped: l }, e.attributes.popper = Object.assign({}, e.attributes.popper, { "data-popper-reference-hidden": d, "data-popper-escaped": l }) } }; const ct = { name: "offset", enabled: !0, phase: "main", requires: ["popperOffsets"], fn: function (e) { var i = e.state, r = e.options, a = e.name, s = r.offset, p = void 0 === s ? [0, 0] : s, c = l.reduce((function (e, r) { return e[r] = function (e, i, r) { var a = g(e), s = [o, t].indexOf(a) >= 0 ? -1 : 1, p = "function" == typeof r ? r(Object.assign({}, i, { placement: e })) : r, c = p[0], d = p[1]; return c = c || 0, d = (d || 0) * s, [o, n].indexOf(a) >= 0 ? { x: d, y: c } : { x: c, y: d } }(r, i.rects, p), e }), {}), d = c[i.placement], f = d.x, u = d.y; null != i.modifiersData.popperOffsets && (i.modifiersData.popperOffsets.x += f, i.modifiersData.popperOffsets.y += u), i.modifiersData[a] = c } }; const dt = { name: "popperOffsets", enabled: !0, phase: "read", fn: function (t) { var e = t.state, n = t.name; e.modifiersData[n] = ot({ reference: e.rects.reference, element: e.rects.popper, strategy: "absolute", placement: e.placement }) }, data: {} }; const lt = { name: "preventOverflow", enabled: !0, phase: "main", fn: function (i) { var r = i.state, s = i.options, p = i.name, c = s.mainAxis, d = void 0 === c || c, l = s.altAxis, f = void 0 !== l && l, u = s.boundary, m = s.rootBoundary, h = s.altBoundary, b = s.padding, v = s.tether, y = void 0 === v || v, O = s.tetherOffset, E = void 0 === O ? 0 : O, A = it(r, { boundary: u, rootBoundary: m, padding: b, altBoundary: h }), j = g(r.placement), D = W(r.placement), k = !D, L = M(j), N = function (t) { return "x" === t ? "y" : "x" }(L), V = r.modifiersData.popperOffsets, C = r.rects.reference, P = r.rects.popper, B = "function" == typeof E ? E(Object.assign({}, r.rects, { placement: r.placement })) : E, R = "number" == typeof B ? { mainAxis: B, altAxis: B } : Object.assign({ mainAxis: 0, altAxis: 0 }, B), I = r.modifiersData.offset ? r.modifiersData.offset[r.placement] : null, _ = { x: 0, y: 0 }; if (V) { if (d) { var U, q = "y" === L ? t : o, $ = "y" === L ? e : n, Y = "y" === L ? "height" : "width", z = V[L], F = z + A[q], X = z - A[$], J = y ? -P[Y] / 2 : 0, G = D === a ? C[Y] : P[Y], K = D === a ? -P[Y] : -C[Y], Q = r.elements.arrow, Z = y && Q ? T(Q) : { width: 0, height: 0 }, tt = r.modifiersData["arrow#persistent"] ? r.modifiersData["arrow#persistent"].padding : { top: 0, right: 0, bottom: 0, left: 0 }, et = tt[q], nt = tt[$], ot = H(0, C[Y], Z[Y]), rt = k ? C[Y] / 2 - J - ot - et - R.mainAxis : G - ot - et - R.mainAxis, at = k ? -C[Y] / 2 + J + ot + nt + R.mainAxis : K + ot + nt + R.mainAxis, st = r.elements.arrow && S(r.elements.arrow), pt = st ? "y" === L ? st.clientTop || 0 : st.clientLeft || 0 : 0, ct = null != (U = null == I ? void 0 : I[L]) ? U : 0, dt = z + at - ct, lt = H(y ? w(F, z + rt - ct - pt) : F, z, y ? x(X, dt) : X); V[L] = lt, _[L] = lt - z } if (f) { var ft, ut = "x" === L ? t : o, mt = "x" === L ? e : n, ht = V[N], bt = "y" === N ? "height" : "width", vt = ht + A[ut], yt = ht - A[mt], gt = -1 !== [t, o].indexOf(j), xt = null != (ft = null == I ? void 0 : I[N]) ? ft : 0, wt = gt ? vt : ht - C[bt] - P[bt] - xt + R.altAxis, Ot = gt ? ht + C[bt] + P[bt] - xt - R.altAxis : yt, Et = y && gt ? function (t, e, n) { var o = H(t, e, n); return o > n ? n : o }(wt, ht, Ot) : H(y ? wt : vt, ht, y ? Ot : yt); V[N] = Et, _[N] = Et - ht } r.modifiersData[p] = _ } }, requiresIfExists: ["offset"] }; function ft(t, e, n) { void 0 === n && (n = !1); var o = b(e), i = b(e) && function (t) { var e = t.getBoundingClientRect(), n = O(e.width) / t.offsetWidth || 1, o = O(e.height) / t.offsetHeight || 1; return 1 !== n || 1 !== o }(e), r = N(e), a = j(t, i, n), s = { scrollLeft: 0, scrollTop: 0 }, p = { x: 0, y: 0 }; return (o || !o && !n) && (("body" !== u(e) || K(r)) && (s = function (t) { return t !== m(t) && b(t) ? function (t) { return { scrollLeft: t.scrollLeft, scrollTop: t.scrollTop } }(t) : J(t) }(e)), b(e) ? ((p = j(e, !0)).x += e.clientLeft, p.y += e.clientTop) : r && (p.x = G(r))), { x: a.left + s.scrollLeft - p.x, y: a.top + s.scrollTop - p.y, width: a.width, height: a.height } } function ut(t) { var e = new Map, n = new Set, o = []; function i(t) { n.add(t.name), [].concat(t.requires || [], t.requiresIfExists || []).forEach((function (t) { if (!n.has(t)) { var o = e.get(t); o && i(o) } })), o.push(t) } return t.forEach((function (t) { e.set(t.name, t) })), t.forEach((function (t) { n.has(t.name) || i(t) })), o } function mt(t) { var e; return function () { return e || (e = new Promise((function (n) { Promise.resolve().then((function () { e = void 0, n(t()) })) }))), e } } var ht = { placement: "bottom", modifiers: [], strategy: "absolute" }; function bt() { for (var t = arguments.length, e = new Array(t), n = 0; n < t; n++)e[n] = arguments[n]; return !e.some((function (t) { return !(t && "function" == typeof t.getBoundingClientRect) })) } var vt = function (t) { void 0 === t && (t = {}); var e = t, n = e.defaultModifiers, o = void 0 === n ? [] : n, i = e.defaultOptions, r = void 0 === i ? ht : i; return function (t, e, n) { void 0 === n && (n = r); var i = { placement: "bottom", orderedModifiers: [], options: Object.assign({}, ht, r), modifiersData: {}, elements: { reference: t, popper: e }, attributes: {}, styles: {} }, a = [], s = !1, p = { state: i, setOptions: function (n) { var s = "function" == typeof n ? n(i.options) : n; c(), i.options = Object.assign({}, r, i.options, s), i.scrollParents = { reference: h(t) ? Z(t) : t.contextElement ? Z(t.contextElement) : [], popper: Z(e) }; var d = function (t) { var e = ut(t); return f.reduce((function (t, n) { return t.concat(e.filter((function (t) { return t.phase === n }))) }), []) }(function (t) { var e = t.reduce((function (t, e) { var n = t[e.name]; return t[e.name] = n ? Object.assign({}, n, e, { options: Object.assign({}, n.options, e.options), data: Object.assign({}, n.data, e.data) }) : e, t }), {}); return Object.keys(e).map((function (t) { return e[t] })) }([].concat(o, i.options.modifiers))); return i.orderedModifiers = d.filter((function (t) { return t.enabled })), i.orderedModifiers.forEach((function (t) { var e = t.name, n = t.options, o = void 0 === n ? {} : n, r = t.effect; if ("function" == typeof r) { var s = r({ state: i, name: e, instance: p, options: o }), c = function () { }; a.push(s || c) } })), p.update() }, forceUpdate: function () { if (!s) { var t = i.elements, e = t.reference, n = t.popper; if (bt(e, n)) { i.rects = { reference: ft(e, S(n), "fixed" === i.options.strategy), popper: T(n) }, i.reset = !1, i.placement = i.options.placement, i.orderedModifiers.forEach((function (t) { return i.modifiersData[t.name] = Object.assign({}, t.data) })); for (var o = 0; o < i.orderedModifiers.length; o++)if (!0 !== i.reset) { var r = i.orderedModifiers[o], a = r.fn, c = r.options, d = void 0 === c ? {} : c, l = r.name; "function" == typeof a && (i = a({ state: i, options: d, name: l, instance: p }) || i) } else i.reset = !1, o = -1 } } }, update: mt((function () { return new Promise((function (t) { p.forceUpdate(), t(i) })) })), destroy: function () { c(), s = !0 } }; if (!bt(t, e)) return p; function c() { a.forEach((function (t) { return t() })), a = [] } return p.setOptions(n).then((function (t) { !s && n.onFirstUpdate && n.onFirstUpdate(t) })), p } }({ defaultModifiers: [$, dt, U, y, ct, rt, lt, R, pt] }), yt = "tippy-content", gt = "tippy-arrow", xt = "tippy-svg-arrow", wt = { passive: !0, capture: !0 }, Ot = function () { return document.body }; function Et(t, e, n) { return Array.isArray(t) ? t[e] ?? (Array.isArray(n) ? n[e] : n) : t } function At(t, e) { var n = {}.toString.call(t); return 0 === n.indexOf("[object") && n.indexOf(e + "]") > -1 } function jt(t, e) { return "function" == typeof t ? t.apply(void 0, e) : t } function Tt(t, e) { return 0 === e ? t : function (o) { clearTimeout(n), n = setTimeout((function () { t(o) }), e) }; var n } function Dt(t) { return [].concat(t) } function kt(t, e) { -1 === t.indexOf(e) && t.push(e) } function Lt(t) { return [].slice.call(t) } function Nt(t) { return Object.keys(t).reduce((function (e, n) { return void 0 !== t[n] && (e[n] = t[n]), e }), {}) } function Vt() { return document.createElement("div") } function Ct(t) { return ["Element", "Fragment"].some((function (e) { return At(t, e) })) } function St(t) { return Ct(t) ? [t] : function (t) { return At(t, "NodeList") }(t) ? Lt(t) : Array.isArray(t) ? t : Lt(document.querySelectorAll(t)) } function Mt(t, e) { t.forEach((function (t) { t && (t.style.transitionDuration = e + "ms") })) } function Ht(t, e) { t.forEach((function (t) { t && t.setAttribute("data-state", e) })) } function Pt(t, e, n) { var o = e + "EventListener";["transitionend", "webkitTransitionEnd"].forEach((function (e) { t[o](e, n) })) } function Bt(t, e) { for (var n = e; n;) { var o; if (t.contains(n)) return !0; n = null == n.getRootNode || null == (o = n.getRootNode()) ? void 0 : o.host } return !1 } var Rt = { isTouch: !1 }, Wt = 0; function It() { Rt.isTouch || (Rt.isTouch = !0, window.performance && document.addEventListener("mousemove", _t)) } function _t() { var t = performance.now(); t - Wt < 20 && (Rt.isTouch = !1, document.removeEventListener("mousemove", _t)), Wt = t } function Ut() { var t = document.activeElement; if (function (t) { return !(!t || !t._tippy || t._tippy.reference !== t) }(t)) { var e = t._tippy; t.blur && !e.state.isVisible && t.blur() } } var qt, $t = !!(typeof window < "u" && typeof document < "u") && !!window.msCrypto; function Yt(t) { return [t + "() was called on a" + ("destroy" === t ? "n already-" : " ") + "destroyed instance. This is a no-op but", "indicates a potential memory leak."].join(" ") } function zt(t) { return t.replace(/[ \t]{2,}/g, " ").replace(/^[ \t]*/gm, "").trim() } function Ft(t) { return zt("\n  %ctippy.js\n\n  %c" + zt(t) + "\n\n  %c👷‍ This is a development-only message. It will be removed in production.\n  ") } function Xt(t) { return [Ft(t), "color: #00C584; font-size: 1.3em; font-weight: bold;", "line-height: 1.5", "color: #a6a095;"] } function Jt(t, e) { var n; t && !qt.has(e) && (qt.add(e), (n = console).warn.apply(n, Xt(e))) } function Gt(t, e) { var n; t && !qt.has(e) && (qt.add(e), (n = console).error.apply(n, Xt(e))) } "production" !== {}.NODE_ENV && (qt = new Set); var Kt = { animateFill: !1, followCursor: !1, inlinePositioning: !1, sticky: !1 }, Qt = Object.assign({ appendTo: Ot, aria: { content: "auto", expanded: "auto" }, delay: 0, duration: [300, 250], getReferenceClientRect: null, hideOnClick: !0, ignoreAttributes: !1, interactive: !1, interactiveBorder: 2, interactiveDebounce: 0, moveTransition: "", offset: [0, 10], onAfterUpdate: function () { }, onBeforeUpdate: function () { }, onCreate: function () { }, onDestroy: function () { }, onHidden: function () { }, onHide: function () { }, onMount: function () { }, onShow: function () { }, onShown: function () { }, onTrigger: function () { }, onUntrigger: function () { }, onClickOutside: function () { }, placement: "top", plugins: [], popperOptions: {}, render: null, showOnCreate: !1, touch: !0, trigger: "mouseenter focus", triggerTarget: null }, Kt, { allowHTML: !1, animation: "fade", arrow: !0, content: "", inertia: !1, maxWidth: 350, role: "tooltip", theme: "", zIndex: 9999 }), Zt = Object.keys(Qt); function te(t) { var e = (t.plugins || []).reduce((function (e, n) { var o, i = n.name, r = n.defaultValue; i && (e[i] = void 0 !== t[i] ? t[i] : null != (o = Qt[i]) ? o : r); return e }), {}); return Object.assign({}, t, e) } function ee(t, e) { var n = Object.assign({}, e, { content: jt(e.content, [t]) }, e.ignoreAttributes ? {} : function (t, e) { return (e ? Object.keys(te(Object.assign({}, Qt, { plugins: e }))) : Zt).reduce((function (e, n) { var o = (t.getAttribute("data-tippy-" + n) || "").trim(); if (!o) return e; if ("content" === n) e[n] = o; else try { e[n] = JSON.parse(o) } catch { e[n] = o } return e }), {}) }(t, e.plugins)); return n.aria = Object.assign({}, Qt.aria, n.aria), n.aria = { expanded: "auto" === n.aria.expanded ? e.interactive : n.aria.expanded, content: "auto" === n.aria.content ? e.interactive ? null : "describedby" : n.aria.content }, n } function ne(t, e) { void 0 === t && (t = {}), void 0 === e && (e = []), Object.keys(t).forEach((function (t) { var n = function (t, e) { var n = Object.assign({}, t); return e.forEach((function (t) { delete n[t] })), n }(Qt, Object.keys(Kt)), o = !function (t, e) { return {}.hasOwnProperty.call(t, e) }(n, t); o && (o = 0 === e.filter((function (e) { return e.name === t })).length), Jt(o, ["`" + t + "`", "is not a valid prop. You may have spelled it incorrectly, or if it's", "a plugin, forgot to pass it in an array as props.plugins.", "\n\n", "All props: https://atomiks.github.io/tippyjs/v6/all-props/\n", "Plugins: https://atomiks.github.io/tippyjs/v6/plugins/"].join(" ")) })) } function oe(t, e) { t.innerHTML = e } function ie(t) { var e = Vt(); return !0 === t ? e.className = gt : (e.className = xt, Ct(t) ? e.appendChild(t) : oe(e, t)), e } function re(t, e) { Ct(e.content) ? (oe(t, ""), t.appendChild(e.content)) : "function" != typeof e.content && (e.allowHTML ? oe(t, e.content) : t.textContent = e.content) } function ae(t) { var e = t.firstElementChild, n = Lt(e.children); return { box: e, content: n.find((function (t) { return t.classList.contains(yt) })), arrow: n.find((function (t) { return t.classList.contains(gt) || t.classList.contains(xt) })), backdrop: n.find((function (t) { return t.classList.contains("tippy-backdrop") })) } } function se(t) { var e = Vt(), n = Vt(); n.className = "tippy-box", n.setAttribute("data-state", "hidden"), n.setAttribute("tabindex", "-1"); var o = Vt(); function i(n, o) { var i = ae(e), r = i.box, a = i.content, s = i.arrow; o.theme ? r.setAttribute("data-theme", o.theme) : r.removeAttribute("data-theme"), "string" == typeof o.animation ? r.setAttribute("data-animation", o.animation) : r.removeAttribute("data-animation"), o.inertia ? r.setAttribute("data-inertia", "") : r.removeAttribute("data-inertia"), r.style.maxWidth = "number" == typeof o.maxWidth ? o.maxWidth + "px" : o.maxWidth, o.role ? r.setAttribute("role", o.role) : r.removeAttribute("role"), (n.content !== o.content || n.allowHTML !== o.allowHTML) && re(a, t.props), o.arrow ? s ? n.arrow !== o.arrow && (r.removeChild(s), r.appendChild(ie(o.arrow))) : r.appendChild(ie(o.arrow)) : s && r.removeChild(s) } return o.className = yt, o.setAttribute("data-state", "hidden"), re(o, t.props), e.appendChild(n), n.appendChild(o), i(t.props, t.props), { popper: e, onUpdate: i } } se.$$tippy = !0; var pe = 1, ce = [], de = []; function le(t, e) { var n, o, i, r, a, s, p, c = ee(t, Object.assign({}, Qt, te(Nt(e)))), d = !1, l = !1, f = !1, u = !1, m = [], h = Tt(z, c.interactiveDebounce), b = pe++, v = function (t) { return t.filter((function (e, n) { return t.indexOf(e) === n })) }(c.plugins), y = { id: b, reference: t, popper: Vt(), popperInstance: null, props: c, state: { isEnabled: !0, isVisible: !1, isDestroyed: !1, isMounted: !1, isShown: !1 }, plugins: v, clearDelayTimeouts: function () { clearTimeout(n), clearTimeout(o), cancelAnimationFrame(i) }, setProps: function (e) { if ("production" !== {}.NODE_ENV && Jt(y.state.isDestroyed, Yt("setProps")), !y.state.isDestroyed) { C("onBeforeUpdate", [y, e]), $(); var n = y.props, o = ee(t, Object.assign({}, n, Nt(e), { ignoreAttributes: !0 })); y.props = o, q(), n.interactiveDebounce !== o.interactiveDebounce && (H(), h = Tt(z, o.interactiveDebounce)), n.triggerTarget && !o.triggerTarget ? Dt(n.triggerTarget).forEach((function (t) { t.removeAttribute("aria-expanded") })) : o.triggerTarget && t.removeAttribute("aria-expanded"), M(), V(), w && w(n, o), y.popperInstance && (G(), Q().forEach((function (t) { requestAnimationFrame(t._tippy.popperInstance.forceUpdate) }))), C("onAfterUpdate", [y, e]) } }, setContent: function (t) { y.setProps({ content: t }) }, show: function () { "production" !== {}.NODE_ENV && Jt(y.state.isDestroyed, Yt("show")); var t = y.state.isVisible, e = y.state.isDestroyed, n = !y.state.isEnabled, o = Rt.isTouch && !y.props.touch, i = Et(y.props.duration, 0, Qt.duration); if (!(t || e || n || o || D().hasAttribute("disabled") || (C("onShow", [y], !1), !1 === y.props.onShow(y)))) { if (y.state.isVisible = !0, T() && (x.style.visibility = "visible"), V(), W(), y.state.isMounted || (x.style.transition = "none"), T()) { var r = L(); Mt([r.box, r.content], 0) } s = function () { var t; if (y.state.isVisible && !u) { if (u = !0, x.offsetHeight, x.style.transition = y.props.moveTransition, T() && y.props.animation) { var e = L(), n = e.box, o = e.content; Mt([n, o], i), Ht([n, o], "visible") } S(), M(), kt(de, y), null == (t = y.popperInstance) || t.forceUpdate(), C("onMount", [y]), y.props.animation && T() && function (t, e) { _(t, e) }(i, (function () { y.state.isShown = !0, C("onShown", [y]) })) } }, function () { var t, e = y.props.appendTo, n = D(); t = y.props.interactive && e === Ot || "parent" === e ? n.parentNode : jt(e, [n]), t.contains(x) || t.appendChild(x), y.state.isMounted = !0, G(), "production" !== {}.NODE_ENV && Jt(y.props.interactive && e === Qt.appendTo && n.nextElementSibling !== x, ["Interactive tippy element may not be accessible via keyboard", "navigation because it is not directly after the reference element", "in the DOM source order.", "\n\n", "Using a wrapper <div> or <span> tag around the reference element", "solves this by creating a new parentNode context.", "\n\n", "Specifying `appendTo: document.body` silences this warning, but it", "assumes you are using a focus management solution to handle", "keyboard navigation.", "\n\n", "See: https://atomiks.github.io/tippyjs/v6/accessibility/#interactivity"].join(" ")) }() } }, hide: function () { "production" !== {}.NODE_ENV && Jt(y.state.isDestroyed, Yt("hide")); var t = !y.state.isVisible, e = y.state.isDestroyed, n = !y.state.isEnabled, o = Et(y.props.duration, 1, Qt.duration); if (!(t || e || n) && (C("onHide", [y], !1), !1 !== y.props.onHide(y))) { if (y.state.isVisible = !1, y.state.isShown = !1, u = !1, d = !1, T() && (x.style.visibility = "hidden"), H(), I(), V(!0), T()) { var i = L(), r = i.box, a = i.content; y.props.animation && (Mt([r, a], o), Ht([r, a], "hidden")) } S(), M(), y.props.animation ? T() && function (t, e) { _(t, (function () { !y.state.isVisible && x.parentNode && x.parentNode.contains(x) && e() })) }(o, y.unmount) : y.unmount() } }, hideWithInteractivity: function (t) { "production" !== {}.NODE_ENV && Jt(y.state.isDestroyed, Yt("hideWithInteractivity")), k().addEventListener("mousemove", h), kt(ce, h), h(t) }, enable: function () { y.state.isEnabled = !0 }, disable: function () { y.hide(), y.state.isEnabled = !1 }, unmount: function () { "production" !== {}.NODE_ENV && Jt(y.state.isDestroyed, Yt("unmount")), y.state.isVisible && y.hide(), y.state.isMounted && (K(), Q().forEach((function (t) { t._tippy.unmount() })), x.parentNode && x.parentNode.removeChild(x), de = de.filter((function (t) { return t !== y })), y.state.isMounted = !1, C("onHidden", [y])) }, destroy: function () { "production" !== {}.NODE_ENV && Jt(y.state.isDestroyed, Yt("destroy")), !y.state.isDestroyed && (y.clearDelayTimeouts(), y.unmount(), $(), delete t._tippy, y.state.isDestroyed = !0, C("onDestroy", [y])) } }; if (!c.render) return "production" !== {}.NODE_ENV && Gt(!0, "render() function has not been supplied."), y; var g = c.render(y), x = g.popper, w = g.onUpdate; x.setAttribute("data-tippy-root", ""), x.id = "tippy-" + y.id, y.popper = x, t._tippy = y, x._tippy = y; var O = v.map((function (t) { return t.fn(y) })), E = t.hasAttribute("aria-expanded"); return q(), M(), V(), C("onCreate", [y]), c.showOnCreate && Z(), x.addEventListener("mouseenter", (function () { y.props.interactive && y.state.isVisible && y.clearDelayTimeouts() })), x.addEventListener("mouseleave", (function () { y.props.interactive && y.props.trigger.indexOf("mouseenter") >= 0 && k().addEventListener("mousemove", h) })), y; function A() { var t = y.props.touch; return Array.isArray(t) ? t : [t, 0] } function j() { return "hold" === A()[0] } function T() { var t; return !(null == (t = y.props.render) || !t.$$tippy) } function D() { return p || t } function k() { var t = D().parentNode; return t ? function (t) { var e, n = Dt(t)[0]; return null != n && null != (e = n.ownerDocument) && e.body ? n.ownerDocument : document }(t) : document } function L() { return ae(x) } function N(t) { return y.state.isMounted && !y.state.isVisible || Rt.isTouch || r && "focus" === r.type ? 0 : Et(y.props.delay, t ? 0 : 1, Qt.delay) } function V(t) { void 0 === t && (t = !1), x.style.pointerEvents = y.props.interactive && !t ? "" : "none", x.style.zIndex = "" + y.props.zIndex } function C(t, e, n) { var o; (void 0 === n && (n = !0), O.forEach((function (n) { n[t] && n[t].apply(n, e) })), n) && (o = y.props)[t].apply(o, e) } function S() { var e = y.props.aria; if (e.content) { var n = "aria-" + e.content, o = x.id; Dt(y.props.triggerTarget || t).forEach((function (t) { var e = t.getAttribute(n); if (y.state.isVisible) t.setAttribute(n, e ? e + " " + o : o); else { var i = e && e.replace(o, "").trim(); i ? t.setAttribute(n, i) : t.removeAttribute(n) } })) } } function M() { !E && y.props.aria.expanded && Dt(y.props.triggerTarget || t).forEach((function (t) { y.props.interactive ? t.setAttribute("aria-expanded", y.state.isVisible && t === D() ? "true" : "false") : t.removeAttribute("aria-expanded") })) } function H() { k().removeEventListener("mousemove", h), ce = ce.filter((function (t) { return t !== h })) } function P(e) { if (!Rt.isTouch || !f && "mousedown" !== e.type) { var n = e.composedPath && e.composedPath()[0] || e.target; if (!y.props.interactive || !Bt(x, n)) { if (Dt(y.props.triggerTarget || t).some((function (t) { return Bt(t, n) }))) { if (Rt.isTouch || y.state.isVisible && y.props.trigger.indexOf("click") >= 0) return } else C("onClickOutside", [y, e]); !0 === y.props.hideOnClick && (y.clearDelayTimeouts(), y.hide(), l = !0, setTimeout((function () { l = !1 })), y.state.isMounted || I()) } } } function B() { f = !0 } function R() { f = !1 } function W() { var t = k(); t.addEventListener("mousedown", P, !0), t.addEventListener("touchend", P, wt), t.addEventListener("touchstart", R, wt), t.addEventListener("touchmove", B, wt) } function I() { var t = k(); t.removeEventListener("mousedown", P, !0), t.removeEventListener("touchend", P, wt), t.removeEventListener("touchstart", R, wt), t.removeEventListener("touchmove", B, wt) } function _(t, e) { var n = L().box; function o(t) { t.target === n && (Pt(n, "remove", o), e()) } if (0 === t) return e(); Pt(n, "remove", a), Pt(n, "add", o), a = o } function U(e, n, o) { void 0 === o && (o = !1), Dt(y.props.triggerTarget || t).forEach((function (t) { t.addEventListener(e, n, o), m.push({ node: t, eventType: e, handler: n, options: o }) })) } function q() { j() && (U("touchstart", Y, { passive: !0 }), U("touchend", F, { passive: !0 })), function (t) { return t.split(/\s+/).filter(Boolean) }(y.props.trigger).forEach((function (t) { if ("manual" !== t) switch (U(t, Y), t) { case "mouseenter": U("mouseleave", F); break; case "focus": U($t ? "focusout" : "blur", X); break; case "focusin": U("focusout", X) } })) } function $() { m.forEach((function (t) { var e = t.node, n = t.eventType, o = t.handler, i = t.options; e.removeEventListener(n, o, i) })), m = [] } function Y(t) { var e, n = !1; if (y.state.isEnabled && !J(t) && !l) { var o = "focus" === (null == (e = r) ? void 0 : e.type); r = t, p = t.currentTarget, M(), !y.state.isVisible && function (t) { return At(t, "MouseEvent") }(t) && ce.forEach((function (e) { return e(t) })), "click" === t.type && (y.props.trigger.indexOf("mouseenter") < 0 || d) && !1 !== y.props.hideOnClick && y.state.isVisible ? n = !0 : Z(t), "click" === t.type && (d = !n), n && !o && tt(t) } } function z(t) { var e = t.target, n = D().contains(e) || x.contains(e); "mousemove" === t.type && n || function (t, e) { var n = e.clientX, o = e.clientY; return t.every((function (t) { var e = t.popperRect, i = t.popperState, r = t.props.interactiveBorder, a = function (t) { return t.split("-")[0] }(i.placement), s = i.modifiersData.offset; if (!s) return !0; var p = "bottom" === a ? s.top.y : 0, c = "top" === a ? s.bottom.y : 0, d = "right" === a ? s.left.x : 0, l = "left" === a ? s.right.x : 0, f = e.top - o + p > r, u = o - e.bottom - c > r, m = e.left - n + d > r, h = n - e.right - l > r; return f || u || m || h })) }(Q().concat(x).map((function (t) { var e, n = null == (e = t._tippy.popperInstance) ? void 0 : e.state; return n ? { popperRect: t.getBoundingClientRect(), popperState: n, props: c } : null })).filter(Boolean), t) && (H(), tt(t)) } function F(t) { if (!(J(t) || y.props.trigger.indexOf("click") >= 0 && d)) { if (y.props.interactive) return void y.hideWithInteractivity(t); tt(t) } } function X(t) { y.props.trigger.indexOf("focusin") < 0 && t.target !== D() || y.props.interactive && t.relatedTarget && x.contains(t.relatedTarget) || tt(t) } function J(t) { return !!Rt.isTouch && j() !== t.type.indexOf("touch") >= 0 } function G() { K(); var e = y.props, n = e.popperOptions, o = e.placement, i = e.offset, r = e.getReferenceClientRect, a = e.moveTransition, p = T() ? ae(x).arrow : null, c = r ? { getBoundingClientRect: r, contextElement: r.contextElement || D() } : t, d = [{ name: "offset", options: { offset: i } }, { name: "preventOverflow", options: { padding: { top: 2, bottom: 2, left: 5, right: 5 } } }, { name: "flip", options: { padding: 5 } }, { name: "computeStyles", options: { adaptive: !a } }, { name: "$$tippy", enabled: !0, phase: "beforeWrite", requires: ["computeStyles"], fn: function (t) { var e = t.state; if (T()) { var n = L().box;["placement", "reference-hidden", "escaped"].forEach((function (t) { "placement" === t ? n.setAttribute("data-placement", e.placement) : e.attributes.popper["data-popper-" + t] ? n.setAttribute("data-" + t, "") : n.removeAttribute("data-" + t) })), e.attributes.popper = {} } } }]; T() && p && d.push({ name: "arrow", options: { element: p, padding: 3 } }), d.push.apply(d, (null == n ? void 0 : n.modifiers) || []), y.popperInstance = vt(c, x, Object.assign({}, n, { placement: o, onFirstUpdate: s, modifiers: d })) } function K() { y.popperInstance && (y.popperInstance.destroy(), y.popperInstance = null) } function Q() { return Lt(x.querySelectorAll("[data-tippy-root]")) } function Z(t) { y.clearDelayTimeouts(), t && C("onTrigger", [y, t]), W(); var e = N(!0), o = A(), i = o[0], r = o[1]; Rt.isTouch && "hold" === i && r && (e = r), e ? n = setTimeout((function () { y.show() }), e) : y.show() } function tt(t) { if (y.clearDelayTimeouts(), C("onUntrigger", [y, t]), y.state.isVisible) { if (!(y.props.trigger.indexOf("mouseenter") >= 0 && y.props.trigger.indexOf("click") >= 0 && ["mouseleave", "mousemove"].indexOf(t.type) >= 0 && d)) { var e = N(!1); e ? o = setTimeout((function () { y.state.isVisible && y.hide() }), e) : i = requestAnimationFrame((function () { y.hide() })) } } else I() } } function fe(t, e) { void 0 === e && (e = {}); var n = Qt.plugins.concat(e.plugins || []); "production" !== {}.NODE_ENV && (function (t) { var e = !t, n = "[object Object]" === Object.prototype.toString.call(t) && !t.addEventListener; Gt(e, ["tippy() was passed", "`" + String(t) + "`", "as its targets (first) argument. Valid types are: String, Element,", "Element[], or NodeList."].join(" ")), Gt(n, ["tippy() was passed a plain object which is not supported as an argument", "for virtual positioning. Use props.getReferenceClientRect instead."].join(" ")) }(t), ne(e, n)), document.addEventListener("touchstart", It, wt), window.addEventListener("blur", Ut); var o = Object.assign({}, e, { plugins: n }), i = St(t); if ("production" !== {}.NODE_ENV) { var r = Ct(o.content), a = i.length > 1; Jt(r && a, ["tippy() was passed an Element as the `content` prop, but more than", "one tippy instance was created by this invocation. This means the", "content element will only be appended to the last tippy instance.", "\n\n", "Instead, pass the .innerHTML of the element, or use a function that", "returns a cloned version of the element instead.", "\n\n", "1) content: element.innerHTML\n", "2) content: () => element.cloneNode(true)"].join(" ")) } var s = i.reduce((function (t, e) { var n = e && le(e, o); return n && t.push(n), t }), []); return Ct(t) ? s[0] : s } fe.defaultProps = Qt, fe.setDefaultProps = function (t) { "production" !== {}.NODE_ENV && ne(t, []), Object.keys(t).forEach((function (e) { Qt[e] = t[e] })) }, fe.currentInput = Rt, Object.assign({}, y, { effect: function (t) { var e = t.state, n = { popper: { position: e.options.strategy, left: "0", top: "0", margin: "0" }, arrow: { position: "absolute" }, reference: {} }; Object.assign(e.elements.popper.style, n.popper), e.styles = n, e.elements.arrow && Object.assign(e.elements.arrow.style, n.arrow) } }), fe.setDefaultProps({ render: se }); class ue { constructor() { this.data = {} } set(t, e) { this.data[t] = e } get(t) { return this.data[t] } } const me = { Booster: class { constructor(t) { this.options = t } log(t, e) { const n = [`%c[${this.options.title}] ${t}. Link to documentation ${this.options.documentationLink}`, "\n      display: inline-block;\n      padding: 4px 6px;\n      border-radius: 4px;\n      line-height: 1.5em;\n      color: #282735;\n      background: linear-gradient(45deg,\n        rgba(185, 205, 255, 0.4) 0%,\n        rgba(201, 182, 255, 0.4) 33%,\n        rgba(239, 184, 255, 0.4) 66%,\n        rgba(255, 210, 177, 0.4) 100%);\n        "]; e ? (console.group(...n), Array.isArray(e) ? console.log(...e) : console.log(e), console.groupEnd()) : console.log(...n) } validate(t, e, n) { if (!t.validate) return !0; if ("function" == typeof t.validate) { if (!t.validate(n)) return this.log(`Invalid value "${n}" for attribute "${e}"`), !1 } else if (!t.validate.includes(n)) return this.log(`Invalid value "${n}" for attribute "${e}"`, ["%cPossible values:%c\n" + t.validate.map((t => `• ${t}`)).join("\n"), "font-weight: 700;", "font-weight: initial;"]), !1; return !0 } parse(t) { const e = new ue; for (const n in this.options.attributes) { const o = this.options.attributes[n], i = t.getAttribute(n); if (!i) { e.set(n, o.defaultValue); continue } if (!this.validate(o, n, i)) continue; let r = i; o.parse && (r = o.parse(i) ?? o.defaultValue), e.set(n, r) } this.options.apply(t, e) } getElements() { return document.querySelectorAll(`[${this.options.name}]`) } init() { this.getElements().forEach((t => this.parse(t))) } }, validation: { isNumber: t => !isNaN(Number(t)) } }; var he, be = ((he = be || {}).Perspective = "perspective", he.Scale = "scale", he.ShiftAway = "shift-away", he.ShiftToward = "shift-toward", he), ve = (t => (t.Rounded = "rounded", t.Sharp = "sharp", t))(ve || {}), ye = (t => (t.Bottom = "bottom", t.Left = "left", t.Right = "right", t.Top = "top", t))(ye || {}), ge = (t => (t.Dark = "dark", t.Light = "light", t.Material = "material", t.Translucence = "translucence", t))(ge || {}), xe = (t => (t.Click = "click", t.Hover = "hover", t))(xe || {}); const we = new me.Booster({ name: "fb-tooltip", attributes: { "fb-tooltip-animation": { defaultValue: "shift-away", validate: Object.values(be) }, "fb-tooltip-arrow": { defaultValue: void 0, validate: Object.values(ve) }, "fb-tooltip-message": { defaultValue: "" }, "fb-tooltip-position": { defaultValue: "top", validate: Object.values(ye) }, "fb-tooltip-show-delay": { defaultValue: 0, validate: me.validation.isNumber, parse: Number }, "fb-tooltip-theme": { defaultValue: "dark", validate: Object.values(ge) }, "fb-tooltip-trigger": { defaultValue: "hover", validate: Object.values(xe) } }, apply: (t, e) => { const n = e.get("fb-tooltip-message"); if (!n) return; const o = { animation: e.get("fb-tooltip-animation"), content: n, delay: [e.get("fb-tooltip-show-delay"), null], placement: e.get("fb-tooltip-position") }; switch (e.get("fb-tooltip-arrow")) { case "rounded": o.arrow = '<svg width="16" height="6" xmlns="http://www.w3.org/2000/svg"><path d="M0 6s1.796-.013 4.67-3.615C5.851.9 6.93.006 8 0c1.07-.006 2.148.887 3.343 2.385C14.233 6.005 16 6 16 6H0z"></svg>'; break; case "sharp": o.arrow = !0; break; default: o.arrow = !1 }const i = e.get("fb-tooltip-theme"); o.theme = "dark" === i ? "" : i; const r = e.get("fb-tooltip-trigger"); o.trigger = "hover" === r ? "mouseenter" : r, fe(t, o) }, title: "Tooltips Booster", documentationLink: "https://www.flowbase.co/booster/tooltips" }), Oe = () => we.init(); "complete" === document.readyState ? Oe() : window.addEventListener("load", Oe) }();
